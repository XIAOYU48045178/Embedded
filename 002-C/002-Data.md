`变量`
--

`我们知道在函数内部定义的变量 当程序执行到它的定义处时 编译器为它在栈上分配空间 函数在栈上分配的空间在此函数执行结束时会释放掉`

`变量其实只不过是程序可操作的存储区的名称 C 中每个变量都有特定的类型 类型决定了变量存储的大小和布局 该范围内的值都可以存储在内存中 运算符可应用于变量上` 

`变量采用先定义后使用的规则` `说明符(一个或多个) 变量或变量变量表达式列表` `说明符包括 变量基本类型的关键字 存储类型 作用域` `相同作用域变量名不能重复`

`> 变量命名`

`变量的名称可以由字母、数字和下划线字符组成 它必须以字母或下划线开头 大写字母和小写字母是不同的 因为 C 是大小写敏感的`

`> 变量初始化`

`首先电脑内存开辟一个空间 然后进行赋值`

`在 C 语言中 变量的初始化是在定义变量的同时为其赋予一个初始值 变量的初始化可以在定义时进行 也可以在后续的代码中进行 初始化器由一个等号 后跟一个常量表达式组成 未初始化的变量的值是未定义的可能包含任意的垃圾值 因此为了避免不确定的行为和错误建议在使用变量之前进行初始化`

`在 C 语言中如果变量没有显式初始化那么它的默认值将取决于该变量的类型和其所在的作用域` `对于全局变量和静态变量在函数内部定义的静态变量和在函数外部定义的全局变量它们的默认初始值为零` `以下是不同类型的变量在没有显式初始化时的默认值 整型变量默认值为 0 浮点型变量默认值为 0.0 字符型变量默认值为 '\0' 即空字符 指针变量默认值为 NULL 表示指针不指向任何有效的内存地址 数组、结构体、联合等复合类型的变量它们的元素或成员将按照相应的规则进行默认初始化这可能包括对元素递归应用默认规则` `需要注意的是局部变量在函数内部定义的非静态变量不会自动初始化为默认值它们的初始值是未定义的 包含垃圾值 因此在使用局部变量之前应该显式地为其赋予一个初始值`

`> 左值 Lvalues 和 右值 Rvalues`

`左值 lvalue 指向内存位置的表达式被称为左值 lvalue 表达式 左值可以出现在赋值号的左边或右边` 

`右值 rvalue 术语右值 rvalue 指的是存储在内存中某些地址的数值 右值是不能对其进行赋值的表达式 也就是说右值可以出现在赋值号的右边但不能出现在赋值号的左边`

`变量是左值因此可以出现在赋值号的左边 数值型的字面值是右值因此不能被赋值 不能出现在赋值号的左边`

`常量`
--

`常量是固定值在程序执行期间不会改变 这些固定的值又叫做字面量 常量可以是任何的基本数据类型 比如整数常量、浮点常量、字符常量 或字符串字面值 也有枚举常量 常量就像是常规的变量 只不过常量的值在定义后不能进行修改 常量可以直接在代码中使用 也可以通过定义常量来使用`

`整数常量也可以带一个后缀 后缀是 U 和 L 的组合 U 表示无符号整数 unsigned L 表示长整数 long 后缀可以是大写 也可以是小写 U 和 L 的顺序任意`

`> 定义常量`

`在 C 中 有两种简单的定义常量的方式 使用 #define 预处理器：#define 可以在程序中定义一个常量 它在编译时会被替换为其对应的值 使用 const 关键字：const 关键字用于声明一个只读变量 即该变量的值不能在程序运行时修改`

`#define 是预处理命令 使用 define 定义常量实际是进行符号替换 #define 符号名 替换列表 #define XI "XIAO YU" 所有的 XI 都会被替换为 XIAO YU`

`! #define 与 const 区别`

`#define 与 const 这两种方式都可以用来定义常量 选择哪种方式取决于具体的需求和编程习惯 通常情况下 建议使用 const 关键字来定义常量 因为它具有类型检查和作用域的优势 而 #define 仅进行简单的文本替换 可能会导致一些意外的问题` 

`#define 预处理指令和 const 关键字在定义常量时有一些区别`

`替换机制：#define 是进行简单的文本替换 而 const 是声明一个具有类型的常量 #define 定义的常量在编译时会被直接替换为其对应的值 而 const 定义的常量在程序运行时会分配内存 并且具有类型信息` 

`类型检查：#define 不进行类型检查 因为它只是进行简单的文本替换 而 const 定义的常量具有类型信息 编译器可以对其进行类型检查 这可以帮助捕获一些潜在的类型错误` 

`作用域：#define 定义的常量没有作用域限制 它在定义之后的整个代码中都有效 而 const 定义的常量具有块级作用域 只在其定义所在的作用域内有效` 

`调试和符号表：使用 #define 定义的常量在符号表中不会有相应的条目 因为它只是进行文本替换 而使用 const 定义的常量会在符号表中有相应的条目有助于调试和可读性` 

`宏常量的运算在预处理展开时就完成性能好 const 的运算在运行时发生有一定性能开销`

`作用域`
--

`块作用域 Block SCOPE`

`块作用域是指在花括号 {} 内声明的变量或函数参数的作用域 这些变量在声明它们的块内是可见的一旦离开这个块它们就不再可用 块作用域通常用于控制结构如 if 语句、for 循环和 while 循环以及函数体内部` 

`文件作用域 File SCOPE`

`文件作用域是指在所有函数外部声明的变量 使用 static 关键字或不加任何存储类说明符的作用域 这些变量在整个文件内都是可见的 但在其他文件中不可见 文件作用域的变量通常用于在多个函数之间共享数据 如果变量前加了 static 关键字 它仍然具有文件作用域 但链接性 Linkage 变为内部链接 意味着它只能在声明它的文件内部被访问`

`函数作用域 Function SCOPE`

`实际上 C语言并没有真正的函数作用域 但是 在C语言中 auto 和 register 存储类说明符 尽管 register 在现代编译器中通常被忽略 暗示了变量只在函数内部有效 这可以看作是一种函数作用域的概念 然而 由于这些说明符是默认的 并且块作用域已经覆盖了函数内部的所有局部变量 因此通常不显式使用这些说明符` 

`函数原型作用域 Function Prototype SCOPE`

`在函数原型中声明的参数只在原型内部具有作用域 这意味着你不能在函数原型外部引用这些参数名 尽管在函数定义内部你可以使用相同的参数名 它们是新的作用域实例  然而 这个作用域在C语言标准中并没有明确提及 因为它主要是一个编译器的实现细节 并且通常对程序员是透明的` 

`程序作用域 Program SCOPE 或 全局作用域 Global SCOPE`

`全局作用域是指在所有函数外部声明的变量 不使用 static 关键字 的作用域 这些变量在整个程序中都是可见的 包括在所有的源文件中 如果它们被正确地声明在头文件或通过外部链接声明  全局变量应该谨慎使用 因为它们可以导致代码难以维护和调试` 

`标签作用域 Label SCOPE`

`虽然这不是一个常见的术语 但在讨论 goto 语句时 标签 label 的作用域是相关的 goto 语句可以跳转到同一函数内用 : 标记的标签处 标签的作用域限于它们所在的函数` 

`局部变量 全局变量`
--

`局部变量 定义在函数里面的变量称为局部变量 如果不进行初始化默认值为随机数` `局部变量在函数或代码块内定义 其作用域和生命周期仅限于该区域 存储在栈上 动态分配并自动回收内存 它们有助于封装函数功能 提高代码模块化` 

`全局变量则在所有函数外部定义整个程序都可见 生命周期贯穿程序运行始终 存储在数据段静态分配内存 全局变量便于跨函数共享数据 但过度使用会降低代码可读性和可维护性且可能引发多线程并发访问问题 使用全局变量时需避免命名冲突防止意外覆盖或修改 同时在多线程环境中应特别小心考虑使用同步机制保护数据一致性`

`全局变量与局部变量在内存中的区别`

`全局变量保存在内存的全局存储区中 占用静态的存储单元 局部变量保存在栈中 只有在所在函数被调用时才动态地为变量分配存储单元`

`基本数据类型`
--

`变量 程序运行过程中其值可以发生变化的量 全局变量可以不赋初始值 局部变量必须赋初始值不赋则为随机数 常量 程序运行过程中其值不能被改变的量`

`不同计算机体系结构中类型所占的比特数可能是不同的` `范围 过了从头再来 int i = 2^31-1 i++ 则 i = -2^31` 

`> 整型`

`! 整型变量`

`整型变量包括 短整型 short int 整型 int 长整型 long int 这些整型变量又可以分为 有符号 signed 无符号 unsigned 两种 在内存中以二进制形式存放 每种类型的整数占有一定大小的地址空间因此他们表示数值范围也有所限制`

`short 2 字节 16 位 取值范围: 有符号 -2^15 ~ 2^15-1 无符号 0 ~ 2^16-1`

`int 4 字节 32 位 取值范围: 有符号 -2^31 ~ 2^31-1 无符号 0 ~ 2^32-1 `

`long 在 32 位系统上通常是 4 字节 在 64 位系统上通常是 8 字节 32 位取值范围: 有符号 -2^31 ~ -2^31-1 无符号 0 ~ 2^32-1 64 位取值范围: 有符号 -2^63 ~ -2^63-1 无符号 0 ~ 2^64-1`

`long long C99 标准引入 8 字节 64 位 取值范围: 有符号 -2^63 ~ 2^63-1 无符号 0 到 2^64-1`

`! 整型常量`

`整型常量可以有八进制整数 以 0 作为前缀 十进制整数 十六进制整数 以 0x 或 0X 作为前缀`

`由于计算机中数据是以二进制进行存放的数据类型的表示范围也一般都是 4 的倍数 因此常将二进制数据以十六进制表示`

`! 整数拆分`

```c
#include<stdio.h>
int main()
{
	int v1 = 98, v2 = 987, v3 = 9876;
	v1 % 10; v1 / 10 % 10;
    v2 % 10; v2 / 10 % 10; v2 / 100 % 10;
    v3 % 10; v3 / 10 % 10; v3 / 100 % 10; v3 / 1000 % 10; 
}
```

`!! 水仙花 100 ~ 999`

```c
#include<stdio.h>
int main()
{
	int i,bw,sw,gw;
	for(i=100;i<=999;i++)
	{
		bw=i/100%10;
		sw=i/10%10;
		gw=i%10;
		if(bw*bw*bw+sw*sw*sw+gw*gw*gw==i){
            printf("%d ",i);
        }
	}	
    return 0;
}
```

`> 实型` `1.0`

`! 实型变量`

`实型变量可分为 单精度 float 精度 6 ~ 7 双精度 double 精度 15 ~ 16 长双精度 long double 精度 18 ~ 19` `精度指的是能够准确表示的小数部分的位数` 

`float 类型通常占用 4 字节 32 位 能表示大约 7 位有效数字的浮点数 范围约为 3.4E-38 到 3.4E+38 有符号` `单精度浮点值单精度是这样的格式 1 位符号 8 位指数 23 位小数`

`double 类型通常占用 8 字节 64 位  提供大约 15 位有效数字 范围扩展至约 2.3E-308 到 1.7E+308` `双精度浮点值 双精度是 1 位符号 11 位指数 52 位小数`

`! 遵循 IEEE 754 标准进行存储` `符号 指数 尾数`

`12.345` `12 -> 1100 0.345 -> 01011... 12.345 近似二进制 为 1100.01011...` `将 0.345 转换为二进制小数这个过程涉及到不断乘以 2 并取结果的整数部分直到小数部分为 0 或达到所需的精度 然而对于 0.345 这样的十进制小数其二进制表示是无限循环的因此在实际存储时我们需要进行舍入以得到一个有限位数的二进制小数` `在 IEEE 754 标准需要规范化浮点数即保小数点前只有一位非零数` `将 1100.01011... 左移 3 位得到 1.10001011... × 2^3` `计算尾数部分: 32 位浮点数中尾数部分占用 23 位 将 1.10001011... 的小数部分 不包括隐含的 1 转换为二进制并填充到 23 位中 不足 23 位 则在前面补 0` `由于小数部分是近似的没有求完 所以假设尾数部分为 10001011000010100011110` `计算指数部分: 在 32 位浮点数中指数部分占用 8 位 之前已经将小数左移了 3 位来规范化它所以指数值为 3` `IEEE 754 标准使用偏移量来表示指数对于 32 位浮点数偏移量为 127` `3 + 127 = 130 二进制表示为 10000010` `12.345 是正数因此符号位为 0` `组合: 符号位: 0 指数部分: 10000010 尾数部分: 10001011000010100011110` `因此小数 12.345 的 32 位二进制表示为: 0 10000010 10001011000010100011110` `这只是一个近似的表示实际转换会有更多位并且尾数部分可能会因为精度限制而进行舍入`

`IEEE 754 标准中浮点数需要规范化 10.0011101101 -> 1.00011101101*2^10 0.0011101101 -> 1.1101101*2^-3`

`! 实型常量` `默认 double 类型`

`实型常量又称为实数一般含有小数部分 C 语言中 实数只有十进制数 分为单精度实数和双精度实数`

`表示方法分为一般形式和指数形式` `0.0 -0.25 20. 3.0E5 -3.1e8 2.1f`

`! 浮点陷阱`

`在计算机中 浮点数通常使用二进制格式表示 这可能导致某些十进制数无法被精确表示 具体来说 8.1 和 3 这两个数在转换为二进制浮点数时可能无法精确表示其十进制值 当进行除法运算时结果可能是一个略微偏离 2.7 的值 尽管这个偏离通常非常小但在进行精确比较时可能会导致问题`

```c
#include<stdio.h>
int main(){
    if(8.1/3 == 2.7){
        printf("YES")
    }else{
        printf("NO")
    }
} --NO
```

`> 字符型`

`! 字符型变量`

`char 1 字节 取值范围: 有符号 -128 ~ 127 无符号 0 ~ 255` `字符变量可以看作整型变量的一种` `作为字符类型 它通常用于表示 ASCII 字符 但也可以作为有符号或无符号整数使用`  `A = 97 - 32`  `0 = 48` `'5' - 48 = 5`

`! 字符型常量`

`字符常量指以单引号括起来的一个字符 只能单引号不能双引号 只能单个字符不能字符串 不能直接参与数值运算以其 ASCII 码值来参与运算`

`转义字符` `\n` `\0` `\t` `\r`

`! 字符判断`

```c
#include<stdio.h>
int main()
{
	char v;
	scanf("%c",&v);
	if(v >= 'A' && v <= 'Z') printf("A ~ Z\n");
	else if(v >= 'a' && v <= 'z') printf("a ~ z\n");
	else if(v >= '0' && v <= '9') printf("0 ~ 9\n");
	else printf("其他字符\n");
    return 0;
}
```

`运算符`
--

`对一个操作数进行运算的运算符称为单目运算符 两个操作数叫做双目运算符 三目运算符对三个操作数进行运算 运算符和括号可以将操作数连接起来组成表达式`

`> 算数运算符` `+` `-` `*` `/` `%` `++` `--`

`取余 不能对小数进行运算` `v1 % v2 = v1 - v1 / v2 * v2` 

`整除 两个整数相除结果还是整数` `1.0`

`自增自减运算符` `++ --` `int v = 0 v++ 表达式的值为 0 v 的值为 1` `作为表达式时` `int k = ++j 即 j=j+1 k=j` `int k = j++ 即 k=j j=j+1`

`> 关系运算符` `> < == != <= >=`

`> 逻辑运算符` `&& || !` `短路`

`短路求值是指在逻辑表达式的求值过程中如果根据已经计算的部分表达式的值就能够确定整个表达式的结果那么剩余的部分将不再计算`

`当使用 AND 运算符时如果左边的操作数为假那么右边的操作数就不会被计算`

`当使用 OR 运算符时如果左边的操作数为真那么右边的操作数就不会被计算`

```c
#include<stdio.h>
int main(){
    int v1 = 0, v2 = 0;
    0 & (v1 = 5); 0 && (v2 = 5);
    1 & (v1 = 5) && (v2 = 5);
}
```

`> 位运算符` `& | ^ ~ << >>`

```
2 --> 0000 0010        1 --> 0000 0001        2&1 --> 0000 0010 & 0000 0001 = 0
4 --> 0000 0100        3 --> 0000 0011        4&3 --> 0000 0100 & 0000 0011 = 0
8 --> 0000 1000        7 --> 0000 0111        8&7 --> 0000 1000 & 0000 0111 = 0
```

`算术左移 << 符号位不变 低位补 0` `int c=1<<2` `00000001 => 00000100 即 1 * 2 * 2 = 4` `int v1 = -8<<2 -32`

`算术右移 >> 低位溢出符号位不变并用符号位补溢出的高位` `int a=1>>2` `1 => 00000001 => 00000000 即 1 / 2 / 2 = 0` `int -8>>2 -2`

`> 赋值运算符` `=` `+=` `-=` `/=` `*=` `%=`

`赋值运算符的左边只能是变量 右边可以是变量、表达式、常量值` `复合赋值运算符会进行类型转换` `运算顺序从右往左`

`在 C 语言中变量的初始化可以在定义时完成并且可以使用常量 已经定义的变量或表达式的结果来初始化新变量只要这些表达式在编译时是确定的 对于局部变量来说初始化表达式中的变量必须是之前已经定义的这种初始化就是合法的`

```c
#include<stdio.h>
int main(){
    int v1 = 3 + 2;
    int v2 = v1;
    int v3 = 3 + 4, v4 = v1;
    printf("%d %d %d %d\n",v1,v2,v3,v4);
}
```

`> 三元运算符` `运算结果为表达式 1 或 表达式 2 的表达式值`

`! 最值`

```c
#include<stdio.h>
int main(){
    int a=0,b=0,max=0;
    scanf("%d%d",&a,&b);
    max=a>b ? a : b; 
    printf("%d\n",max);
    return 0;
}
```

```c
int a=2,b=3,max=0;
a>b?max=a:max --表达式值为 0
a<b?a:max --表达式值为 2
a>b?max=a:max=b --0 = b 错误
```

```c
#include<stdio.h>
int main(){
    int a = 1, b = 4, c = 3, d = 2;
    printf("%d\n",a<b?a:c<d?c:d);  --可以看作 IF ELSE 实际 ? : 自右向左
    return 0;
}
```

`交换`
--

```c
#include<stdio.h>
void main()
{
	int v1, v2, t;
	scanf("%d%d",&v1,&v2);
	t = v1; v1 = v2; v2 = t;
	printf("%d %d\n",v2,v2);
}
```

```c
#include<stdio.h>
int main(){ --整数 浮点数
    int v1 = 5, v2 = 10;
    v1 = v1 + v2;
    v2 = v1 - v2;
    v1 = v1 - v2;
}
```

```c
#include<stdio.h>
int main(){ --整数
    int v1 = 5, v2 = 10;
    v1 = v1 ^ v2;
    v2 = v1 ^ v2;
    v1 = v1 ^ v2;
}
```

```c
#include<stdio.h>
int main(){ --浮点数
    int v1 = 5, v2 = 10;
    v1 = v1 * v2;
    v2 = v1 / v2;
    v1 = v1 / v2;
}
```

`运算符优先级`
--

`运算符有不同的优先级 所谓优先级就是表达式运算中的运算顺序`

`高优先级的运算符会在低优先级的运算符之前进行结合相当于加括号 如果两个运算符的优先级相同那么看它是从左向右结合还是从右向左结合`

`优先级高仅仅确定了结合顺序而运算顺序仍然是从左到右`

`单目 算数 关系 位 逻辑 三目 赋值 逗号` `只有单目运算符、赋值运算符是从右向左运算的`

`点 括号 花括号 分号` `>` `单目运算符: ++ -- ~ ! sizeof` `>` `算数运算符: * / %` `>` `算数运算符: + -` `>` `位运算符: << >> >>>` `>` `比较运算符: < > <= >=` `>` `比较运算符: == !=` `>` `位运算符: &` `>` `位运算符: ^` `>` `位运算符: |` `>` `逻辑运算符: &&` `>` `逻辑运算符: ||` `>` `三元运算符: ? :` `>` `赋值运算符: = *= /= %=` `>` `复合赋值运算符: += -= <<= >>=` `>` `复合赋值运算符: >>>= &= ^= !=` `>` `逗号`

```c
#include<stdio.h>
int main(){
    int i = 1, j = 0, k = 0;
    i > 0 && !(j == 3) || k > 5 --1
    !(i + 1 > 0) && j == 0 || k > 0 --0
    i < 0 || j == 0 && k > 0 --0
    i += j == k, j = i + 2, k = i + j + i > 0 -- i <- 2 j <- 4 k <- 1
    return 0;
}
```

```c
#include<stdio.h>
int main(){
    int i1; i1 = 20-2,9-6/4,8/2;
    int i2; i2 = (20-2,9-6/4,8/2);
    printf("%d %d\n",i1,i2); --i1 <- 18 i2 <- 4
}
```

```c
#include<stdio.h>
int main(){
    int a=0,b=0,c=0,d=0;
    (a=1)||(b=2)&&(c=3)||(d=4);
    printf("%d\n%d\n%d\n%d\n",a,b,c,d);
    return 0;
}  -- 结合性 相当于加括号 优先级高先加 优先级相同再看是左结合还是右结合再加括号最后运算顺序还是从左向右
```

`类型转换`
--

`> 隐式类型转换`

`若参与运算量的类型不同则先转换成同一类型然后进行运算 转换按数据长度增加的方向进行以保证精度不降低如 int 型和 long 型运算时先把 int 转成 long 型后再进行运算若两种类型的字节数不同转换成字节数高的类型若两种类型的字节数相同且一种有符号一种无符号则转换成无符号类型`

`在赋值运算中赋值号两边量的数据类型不同时赋值号右边量的类型将转换为左边量的类型如果右边量的数据类型长度比左边长时将丢失一部分数据这样会降低精度丢失的部分按四舍五入向前舍入`

`char -> int -> unsigned int` `short -> int -> unsigned int` `int -> unsigned int -> long -> unsigned long -> long long -> unsigned long long -> float -> double -> long double`

`100 - 'A' + 2.5 首先计算 100 - 'A' 将 'A' 转换 int 型数据 65 运算结果为 35 然后计算 35 + 2.5 将 float 型 2.5 转换为 double 型 int 型 35 转换为 double 型 运算结果为 double 型`

`> 强制类型转换`

`显式类型转换需要程序员在代码中显式地指定转换的类型 这通常通过使用类型转换运算符`

`类型转换的注意事项 在进行类型转换时 应谨慎处理 以避免数据丢失或精度下降`

`字符编码表`
--

`字符编码表是一种代码说明表格它规定了字符在计算机中的存储方式 通过字符编码表计算机可以将字符转换为二进制数据也可以将二进制数据转换回字符`

`编码转换 http://tool.chinaz.com/Tools/Unicode.aspx`

`! ASCII`

`适用范围 英文及部分特殊符号` `编码规则 一个字节中的 7 位表示一个字符 最高位为 0` `示例 字符 'A' 的 ASCII 码为 65 二进制表示为 01000001` `A = 97 - 32` `0 = 48` `'5' - 48 = 5`

`! ISO-8859-1`

`适用范围 拉丁语系字符` `编码规则 使用了一个字节中的 8 位 涵盖了更多的字符`

`! GB2312`

`适用范围 简体中文` `编码规则 使用两个字节表示一个字符 包含 6000~7000 个中文和符号` 

`! GBK`

`适用范围 简体中文 扩展了 GB2312 的字符集` `编码规则 同样使用两个字节表示一个字符 但字符集更加广泛 包含2万个中文和符号`

`! Unicode` `兼容 ASCII`

`适用范围 国际标准码表 涵盖了世界上几乎所有的文字` `编码规则 无论是什么文字 都用两个字节或更多存储 Unicode 码表为每种字符分配了一个唯一的编码 从而避免了字符集之间的冲突` `Java 中的 CHAR 类型就使用了这个码表`

`! UTF-8`

`适用范围 基于 Unicode 的变长字符编码` `编码规则 UTF-8 码表使用了 1~4 个字节不等来表示一个字符 其中常用的英文字符使用 1 个字节表示 而中文等复杂字符则使用多个字节表示 UTF-8 码表具有更高的效率并且在网络传输中更加节省带宽`
